
local scalingButton = require "util/scalingButton"

local deadZone = 0.25

local leftJoystick = {
	defaultPos = vmath.vector3(),
	touchPos = vmath.vector3(),
	value = {x=0, y=0},
	maxDist = 150,
	touchId = -1,
	area = {left=175, right=1920/3, top=1080-175, bottom=175}
}

-- Right joystick isn't floating!
local rightJoystick = {
	defaultPos = vmath.vector3(),
	touchPos = vmath.vector3(),
	value = {x=0, y=0},
	maxDist = 150,
	touchId = -1,
	--area = {left=1300,right=1920,top=500,bottom=0}
}


local rotatingSpinner = false
local spinnerTimer = 0
local reconnectWindowIsVisible = false

function init(self)
	msg.post(".", "acquire_input_focus")

	-- get center position of virtual joystick
	local joystick = gui.get_node("joystick_front")
	leftJoystick.defaultPos = gui.get_position(joystick)

	joystick = gui.get_node("right_joystick_front")
	rightJoystick.defaultPos = gui.get_position(joystick)

	-- I did this, so it's not necessary to edit setJoystickPosition function
	rightJoystick.touchPos = rightJoystick.defaultPos 



	self.gameButtons = {
		blue = scalingButton.create("blueButton", 1, buttonReleased, buttonPressed),
		green = scalingButton.create("greenButton", 2, buttonReleased, buttonPressed),
		red = scalingButton.create("redButton", 3, buttonReleased, buttonPressed),
		yellow = scalingButton.create("yellowButton", 4, buttonReleased, buttonPressed)
	}

	self.guiButtons = {
		reconnect = scalingButton.create("reconnectButton", nil, buttonReleased, buttonPressed)
	}

	
	hideReconnectWindow(self)
	showReconnectWindow(self)
end

function buttonPressed(hashedNodeId)

end

function buttonReleased(hashedNodeId)
	if hashedNodeId == hash("reconnectButton") then
		msg.post("/go#client", "reconnect")
		showSpinner()
	end
end

function showReconnectWindow()
	reconnectWindowIsVisible = true
	local node = gui.get_node("reconnectScreen")
	gui.set_position(node, vmath.vector3(1920/2, 1080/2, 0))
	gui.set_scale(node, vmath.vector3(0.9, 0.9, 1))
	gui.animate(node, gui.PROP_SCALE, vmath.vector3(1, 1, 1), gui.EASING_INOUTCUBIC, 0.5)
	--gui.set_text(node, text)
	hideSpinner()
end

function showSpinner()
	local node = gui.get_node("reconnectSpinner")
	local color = gui.get_color(node)
	color.w = 1
	gui.set_color(node, color)
	rotatingSpinner = true
end

function hideSpinner()
	local node = gui.get_node("reconnectSpinner")
	local color = gui.get_color(node)
	color.w = 0
	gui.set_color(node, color)
	rotatingSpinner = false
end

function hideReconnectWindow()
	reconnectWindowIsVisible = false
	local node = gui.get_node("reconnectScreen")
	gui.set_position(node, vmath.vector3(1000)) -- move it far far away
	hideSpinner()
end

function applyDeadZone(joystick)
	local joystickLen = vmath.length(vmath.vector3(joystick.value.x, joystick.value.y, 0))
	if joystickLen < deadZone then
		joystick.value.x = 0
		joystick.value.y = 0
	end
end


function createFrame(self)
	applyDeadZone(leftJoystick)
	applyDeadZone(rightJoystick)
	
	local frame = string.format("%.6f;%.6f;%.6f;%.6f", 
		leftJoystick.value.x, leftJoystick.value.y, 
		rightJoystick.value.x, rightJoystick.value.y)

	local zeroButtonsClicked = true
	for k, button in pairs(self.gameButtons) do
		if button.isPressed then
			zeroButtonsClicked = false
			frame = frame .. ";" .. tostring(button.buttonId )
		end
	end

	if zeroButtonsClicked then
		frame = frame .. ";0"
	end

	frame = frame .. "\n\r"
	return frame
end



function final(self)

end

function update(self, dt)
	if rotatingSpinner then
		
		spinnerTimer = spinnerTimer + dt
		
		if spinnerTimer > 0.05 then
			spinnerTimer = 0
			local rot = gui.get_rotation(gui.get_node("reconnectSpinner"))
			rot.z = rot.z - 31
			gui.set_rotation(gui.get_node("reconnectSpinner"), rot)
		end
	end
end

function on_message(self, message_id, message, sender)

	if message_id == hash("dataRequest") then
		local _frame = createFrame(self)
		msg.post("/go#client", "setControllerData", {frame = _frame})

	elseif message_id == hash("setConnectionText") then
		--gui.set_text(gui.get_node("connectionText"), message.text)
		if message.text == "Connected" then
			hideReconnectWindow()
		elseif message.text == "Disconnected" then
			showReconnectWindow()
		elseif message.text == "Connection failed" then
			
		end
	end

end

function setJoystickPosition(x, y, joystick)

	local button = nil
	if joystick == leftJoystick then
		button = gui.get_node("joystick_front")
	else
		button = gui.get_node("right_joystick_front")
	end

	local pos = gui.get_position(button)
	local diff = vmath.vector3(x, y, 0) - joystick.touchPos
	local len = vmath.length(diff)

	if len < joystick.maxDist then
		-- joystick is inside circle
		gui.set_position(button, vmath.vector3(x, y, 0))
		joystick.value.x = diff.x / joystick.maxDist
		joystick.value.y = diff.y / joystick.maxDist
	else 
		-- joystick is on the edge of circle
		local normalized = vmath.normalize(diff)
		gui.set_position(button, joystick.touchPos + normalized * joystick.maxDist)
		joystick.value.x = normalized.x
		joystick.value.y = normalized.y
	end

end

function isTouchedInJoystickArea(x, y, joystick)
	if x > joystick.area.left and x < joystick.area.right and y < joystick.area.top and y > joystick.area.bottom then
		return true
	end
	return false
end

function on_input(self, action_id, action)

	-- action.touch values:
	-- x = 1422,
	-- tap_count = 0,
	-- pressed = false,
	-- y = 815,
	-- screen_y = 816,
	-- screen_dy = 0,
	-- screen_dx = 0,
	-- dx = 0,
	-- dy = 0,
	-- id = 0,
	-- released = true,
	-- screen_x = 1422
	if action_id == hash("multitouch") then
		for i, touchData in ipairs(action.touch) do -- iterate over every element in action.touch 
			-- gui buttons
			for k, button in pairs(self.guiButtons) do
				button.multitouchUpdate(touchData)
			end

			if reconnectWindowIsVisible then
				break
			end
			
			-- update buttons
			for k, button in pairs(self.gameButtons) do
				button.multitouchUpdate(touchData)
			end


			-- LEFT JOYSTICK
			if touchData.pressed and leftJoystick.touchId == -1 and isTouchedInJoystickArea(touchData.x, touchData.y, leftJoystick) then
				leftJoystick.touchId = touchData.id
				leftJoystick.touchPos = vmath.vector3(touchData.x, touchData.y, 0)
				gui.set_position(gui.get_node("joystick_back"), leftJoystick.touchPos)
			elseif touchData.released and leftJoystick.touchId == touchData.id then
				if leftJoystick.touchId == touchData.id then
					leftJoystick.touchId = -1
					gui.set_position(gui.get_node("joystick_front"), leftJoystick.defaultPos)
					gui.set_position(gui.get_node("joystick_back"), leftJoystick.defaultPos)
					leftJoystick.value.x = 0
					leftJoystick.value.y = 0
				end
			end

			if touchData.id == leftJoystick.touchId then
				setJoystickPosition(touchData.x, touchData.y, leftJoystick)
			end
			-- END OF LEFT JOYSTICK

			-- RIGHT JOYSTICK
			local joystick = gui.get_node("right_joystick_back")
			if touchData.pressed and rightJoystick.touchId == -1 and gui.pick_node(joystick, touchData.x, touchData.y) then
				rightJoystick.touchId = touchData.id
			elseif touchData.released and rightJoystick.touchId == touchData.id then
				if rightJoystick.touchId == touchData.id then
					rightJoystick.touchId = -1
					gui.set_position(gui.get_node("right_joystick_front"), rightJoystick.defaultPos)
					gui.set_position(gui.get_node("right_joystick_back"), rightJoystick.defaultPos)
					rightJoystick.value.x = 0
					rightJoystick.value.y = 0
				end
			end

			if touchData.id == rightJoystick.touchId then
				setJoystickPosition(touchData.x, touchData.y, rightJoystick)
			end
			-- END OF RIGHT JOYSTICK

		end
	elseif action_id == hash("mouse_left") then

		for k, button in pairs(self.guiButtons) do
			button.mouseUpdate(action)
		end
		
		--if reconnectWindowIsVisible then
		--	return
		--end
		
		--for k, button in pairs(self.gameButtons) do
		--	button.mouseUpdate(action)
		--end
	elseif action_id == hash("key_back") then
		os.exit()
	end

end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
