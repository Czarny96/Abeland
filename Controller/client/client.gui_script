local tcp_client = require "defnet.tcp_client"
local p2p_discovery = require "defnet.p2p_discovery"

local P2P_PORT = 50000
local SERVER_IP =  nil
local SERVER_PORT = 5555

local client = nil

local reconnectTimer = 0
local tryToReconnect = false

-- BUGFIX #2
-- Timer used for fixing bug with non-existing server. UDP datagrams can be received 
-- long time after server dc'ed and client thinks, that server is up.
local broadcastTimer = 3

local frame = ""

function init(self)
	self.p2p = p2p_discovery.create(P2P_PORT)
	
	self.p2p.listen("findme", function(ip, port)
		-- see note above (BUGFIX #2)
		if broadcastTimer > 3 and not SERVER_IP then
			SERVER_IP = ip
		end
	end)
end

function onData(data)
	if data == "btn_data" then
		msg.post("/go#ctrlGui", "dataRequest")
		if client then
			client.send(frame)
		end
	end
end

function onDisconnection()
	print("Disconnected")
	client = nil
	SERVER_IP = nil
	broadcastTimer = 0
	msg.post("/go#ctrlGui", "setConnectionText", {text = "Disconnected"})
end

function connectToServer(self, ip, port)
	
	local err
	client, err = tcp_client.create(ip, port, onData, onDisconnection)
	
	if client then
		print("Connected")
		tryToReconnect = false
		msg.post("/go#ctrlGui", "setConnectionText", {text = "Connected"})
	else
		print("Connection failed. How?")
		print(err)
		msg.post("/go#ctrlGui", "setConnectionText", {text = "Connection failed"})
	end
end

function final(self)
	if client then
		client.destroy()
	end
end

function update(self, dt)
	-- SERVER LOGIC
	self.p2p.update()

	reconnectTimer = reconnectTimer + dt
	broadcastTimer = broadcastTimer + dt
	-- server dc'ed and ip is known, so try to reconnect
	if not client and SERVER_IP and reconnectTimer > 2 and tryToReconnect then
		reconnectTimer = 0
		connectToServer(self, SERVER_IP, SERVER_PORT)
	end

	if client then
		client.update()
	end
	-- END OF SERVER LOGIC
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
	if message_id == hash("setControllerData") then
		frame = message.frame
	elseif message_id == hash("reconnect") then
		print("Reconnect clicked")
		tryToReconnect = true
	end

end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
