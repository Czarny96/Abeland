local tcp_client = require "defnet.tcp_client"
local p2p_discovery = require "defnet.p2p_discovery"

local P2P_PORT = 50000
local SERVER_IP =  nil
local SERVER_PORT = 5555

local client = nil

local tryToConnect = false

-- BUGFIX #2
-- Timer used for fixing bug with non-existing server. UDP datagrams can be received 
-- long time after server dc'ed and client thinks, that server is up.
local broadcastTimer = 3

local frame = ""


local function onData(data)
	--print(data)
	if data == "btn_data" then
		
		msg.post("/menu#ctrlGui", "dataRequest")
		if client then
			--print("SENDING FRAME: ", frame)
			client.send(frame)
		end
		
	elseif data == "StartGame" then
		-- hide pop-up window
		g_hideConfirmationWindow()

		g_goToController()
		
	elseif data == "EndGame" then
		
		if g_gameState == g_gameStateEnum.controller then
			-- hide pop-up window
			g_hideConfirmationWindow()
			msg.post("/menu#ctrlGui", "death")
		else
			-- What should we do if player receives EndGame frame while in username/champion select/game/menu/game over?
			--g_goToMainMenu()
			--msg.post("/go#client", "disconnect")
		end
		
	elseif data == "Reset" then
		
		g_goToChampionSelect()
		
	elseif string.sub(data, 1, 1) == "C" then
		-- example: "C;mage" - server confirms, that mage is locked in by this client
		
		msg.post("/menu#championSelect", "playerClassConfirm", {playerClass = string.sub(data, 3, #data)})
		
	elseif string.sub(data, 1, 1) == "A" then
		-- example: "A;2" - 2 players alive
		
		local _alivePlayers = tonumber(string.sub(data, 3, 3))
		msg.post("/menu#gameOverScreen", "alivePlayers", {alivePlayers = _alivePlayers}) -- it should be one digit
		
	end
end

local function onDisconnection()
	print("Disconnected")
	client = nil
	SERVER_IP = nil
	broadcastTimer = 0
	g_showDcWindow()
	g_goToMainMenu()
end

local function connectToServer(self, ip, port)
	local err
	print(ip, port)
	client, err = tcp_client.create(ip, port, onData, onDisconnection)
	if client then
		print("Connected")
		tryToConnect = false
		g_hideConnectingWindow()
		g_goToUsernameField()

	else
		print("Connection failed. How?")
		print(err)
	end
end

function init(self)
	self.p2p = p2p_discovery.create(P2P_PORT)
	
	self.p2p.listen("findme", function(ip, port)
		-- see note above (BUGFIX #2)
		if not client and tryToConnect and broadcastTimer > 2 and not SERVER_IP then
			print("Found server " .. ip .. " " .. port)
			SERVER_IP = ip
			connectToServer(self, SERVER_IP, SERVER_PORT)
		end
	end)
end

function final(self)
	if client then
		client.destroy()
	end
end

function update(self, dt)
	-- SERVER LOGIC
	self.p2p.update()

	broadcastTimer = broadcastTimer + dt
	-- server dc'ed and ip is known, so try to reconnect
	--if not client and SERVER_IP and tryToConnect then
	--	connectToServer(self, SERVER_IP, SERVER_PORT)
	--end

	if client then
		client.update()
	end
	-- END OF SERVER LOGIC
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
	if message_id == hash("setControllerData") then
		frame = message.frame
	elseif message_id == hash("setConnectionFlag") then
		print("Set connection flag: " .. tostring(message.on))
		tryToConnect = message.on
		broadcastTimer = 0
	elseif message_id == hash("disconnect") then
		print("Disconnect")
		if client then
			client.destroy()
			client = nil
			SERVER_IP = nil
			g_goToMainMenu()
		end
	elseif message_id == hash("sendPlayerClass") then
		if client then
			client.send("C;" .. message.playerClass .. "\n\r")
		end
	elseif message_id == hash("sendReady") then
		if client then
			client.send("G;ready\n\r")
		end
	elseif message_id == hash("sendUsername") then
		if client then

			if g_username ~= "" then
				client.send("N;" .. g_username .. "\n\r")
			end
			
		end
	elseif message_id == hash("alivePlayersRequest") then
		-- ask server about number of alive players 
		if client then
			
			client.send("AlivePlayers\n\r")

		end
		
	end

end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
