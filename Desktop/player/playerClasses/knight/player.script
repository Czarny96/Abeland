--KNIGHT
go.property("movingDir", vmath.vector3(0, 0, 0))
go.property("position", vmath.vector3(0, 0, 0))
go.property("health", 200)
go.property("movingSpeed", 180)


function init(self)
	msg.post(".", "acquire_input_focus")

	self.inputCollection = { up = false, down = false, left = false, right = false }
	self.movingFlag = false

	self.wallsTopCollider = false
	self.wallsBottomCollider = false
	self.wallsLeftCollider = false
	self.wallsRightCollider = false
end

local function updateAnimation(self)
		if self.movingDir.x < -0.3 and self.movingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("player_up_left")})
	elseif self.movingDir.x > 0.3 and self.movingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("player_up_right")})
	elseif self.movingDir.x < -0.3 and self.movingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("player_down_left")})
	elseif self.movingDir.x > 0.3 and self.movingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("player_down_right")})
	elseif self.movingDir.y > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("player_up")})
	elseif self.movingDir.y < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("player_down")})
	elseif self.movingDir.x < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("player_left")})
	elseif self.movingDir.x > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("player_right")})
	end
end

function update(self, dt)
	-- Collisions with walls
	if self.wallsTopCollider and self.movingDir.y > 0 then
		self.movingDir.y = 0
	end
	if self.wallsBottomCollider and self.movingDir.y < 0 then
		self.movingDir.y = 0
	end
	if self.wallsLeftCollider and self.movingDir.x < 0 then
		self.movingDir.x = 0
	end
	if self.wallsRightCollider and self.movingDir.x > 0 then
		self.movingDir.x = 0
	end

	
	if self.movingFlag then
		local playerPos = go.get_position()
		local movingDir = vmath.vector3(self.movingDir.x, self.movingDir.y, 0)
		if movingDir ~= vmath.vector3(0,0,0) then
			self.movingDir = vmath.normalize(movingDir)
		end
		playerPos = playerPos + self.movingDir * self.movingSpeed * dt
		go.set_position(playerPos)
	end
	
	updateAnimation(self)
	
	go.set("#player", "position", go.get_position())
	self.movingFlag = false
	self.wallsTopCollider = false
	self.wallsBottomCollider = false
	self.wallsLeftCollider = false
	self.wallsRightCollider = false
end

function handleCollisionWithWall(self, message_id, message, sender)
	local playerPos = go.get_position()
	
	self.movingDir.x = -self.movingDir.x
	self.movingDir.y = -self.movingDir.y
	self.movingDir = vmath.normalize(self.movingDir)
	playerPos = playerPos + self.movingDir * self.movingSpeed
	go.set_position(playerPos)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("move") then
		self.movingDir.x = message.x
		self.movingDir.y = message.y
		self.movingFlag = true
	end
	
	if message_id == hash("contact_point_response") then	
		if message.group == hash("walls") then
			if sender.fragment == hash("wallsTopCollider") then
				self.wallsTopCollider = true
			end
			if sender.fragment == hash("wallsBottomCollider") then
				self.wallsBottomCollider = true
			end
			if sender.fragment == hash("wallsLeftCollider") then
				self.wallsLeftCollider = true
			end
			if sender.fragment == hash("wallsRightCollider") then
				self.wallsRightCollider = true
			end
		end
	end
end