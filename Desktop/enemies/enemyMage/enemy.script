-- ENEMY MAGE
local playersManager = require "managers.playersManager"
local enemyManager = require "managers.enemyManager"
local globals = require "main.globals"

-- Global properties
go.property("movingDir", vmath.vector3(0,0,0))
go.property("maxHealth", 100)
go.property("health", 100)
go.property("damage", 5)
go.property("isRanged", true)

function init(self)
	-- Move force settings
	self.movingSpeed = 180
	self.followDistance = 500
	self.runAwayDistance = 300
	-- Other force settings
	self.knockbackPlayer = 13500
	-- Health label
	label.set_text("#label_hp", self.health)
end

local function lookForClosestPlayer(self)
	-- Count possition diffrence between closest player and enemy to designate enemy moving direction
	self.enemyPos = go.get_position()
	local closestPlayerID = playersManager.getClosestPlayerID(self.enemyPos)
	if closestPlayerID ~= 0 then
		local closestPlayerPos = playersManager.getPlayerPos(closestPlayerID)
		self.distanceToClosestPlayer = vmath.length(closestPlayerPos - self.enemyPos)
		local positionDiffrence = closestPlayerPos - self.enemyPos
		self.movingDir = vmath.normalize(vmath.vector3(positionDiffrence.x, positionDiffrence.y, 0))
	else
		self.distanceToClosestPlayer = (self.followDistance + self.runAwayDistance) / 2
		self.movingDir = vmath.vector3(0)
	end
end

local function updateAnimation(self)
	-- Set proper animation based on enemy moving directory
	if self.movingDir.x < -0.3 and self.movingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_up_left")})
	elseif self.movingDir.x > 0.3 and self.movingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_up_right")})
	elseif self.movingDir.x < -0.3 and self.movingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_down_left")})
	elseif self.movingDir.x > 0.3 and self.movingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_down_right")})
	elseif self.movingDir.y > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_up")})
	elseif self.movingDir.y < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_down")})
	elseif self.movingDir.x < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_left")})
	elseif self.movingDir.x > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_right")})
	else 
		msg.post("#sprite", "play_animation", {id = hash("enemy_mage_down")})
	end
end

local function applyMoveForce(self, dt)
	if self.distanceToClosestPlayer >= self.followDistance then
		msg.post("#collider", "apply_force", {force = self.movingDir * self.movingSpeed * go.get("#collider", "mass"), position = go.get_world_position()})
	elseif self.distanceToClosestPlayer <= self.runAwayDistance then
		msg.post("#collider", "apply_force", {force = -self.movingDir * self.movingSpeed * go.get("#collider", "mass"), position = go.get_world_position()})
	end
end

local function handleDeath(self, dt)
	-- Handling death when health drops below 0
	if self.health <= 0 then
		-- Play death sound
		msg.post("#death_sound", "play_sound", {gain = 0.5})
		enemyManager.removeEnemy(go.get_id())
		go.delete()
	end
end

function update(self, dt)
	-- If game is paused stop enemy
	if globals.getPause() then
		return
	end	

	lookForClosestPlayer(self)
	applyMoveForce(self, dt)
	updateAnimation(self)
	handleDeath(self, dt)
end

local function playersAttacksCollisions(self, message_id, message, sender)
	local attackUrl = msg.url(nil, message.other_id, "attack")
	local attackDmg = go.get(attackUrl, "damage")		
	self.health = self.health - attackDmg
	label.set_text("#label_hp", self.health)
end

local function playersCollisions(self, message_id, message, sender)
	local knockbackDir = vmath.normalize(go.get_position() - message.other_position)
	msg.post("#collider", "apply_force", {force = knockbackDir * go.get("#collider", "mass") * self.knockbackPlayer, position = go.get_world_position()})
	msg.post(message.other_id, "hit", {dmg = self.damage})
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		if message.group == hash("attack") then
			playersAttacksCollisions(self, message_id, message, sender)
		elseif message.group == hash("player") then
			playersCollisions(self, message_id, message, sender)
		end	
	end
	if message_id == hash("kill") then
		go.delete()
	end
end