-- ENEMY MELEE

local playersManager = require "managers.playersManager"
local enemyManager = require "managers.enemyManager"
local globals = require "main.globals"

-- Global properties
go.property("enemyMovingDir", vmath.vector3(0, 0, 0))
go.property("maxHealth", 100)
go.property("health", 100)
go.property("damage", 10)
go.property("isKilled", false)
go.property("isRanged", false)
go.property("moveForce", vmath.vector3(0, 0, 0))

function init(self)
	-- Local Settings
	self.movingSpeed = 50
	self.followDistance = 30
	self.knockbackForce = 300
	self.moveForceReduction = 500	
	-- Local Colliders
	self.wallsCollider = {top = false, bottom = false,left = false,right = false}
	-- Health label
	label.set_text("#label_hp", self.health)
	-- Local Timers
	self.checkClosestPlayerPosTimer = 0
	self.knockbackTimer = 0
	self.moveForceTimer = 0
end

local function lookForClosestPlayer(self)
	-- Count possition diffrence between closest player and enemy to designate enemy moving direction
	local closestPlayerID = playersManager.getClosestPlayerID(self.enemyPos)
	local closestPlayerPos = playersManager.getPlayerPos(closestPlayerID)
	self.distanceToClosestPlayer = vmath.length(closestPlayerPos - self.enemyPos)
	local positionDiffrence = closestPlayerPos - self.enemyPos
	self.enemyMovingDir = vmath.vector3(positionDiffrence.x, positionDiffrence.y, 0)
	self.enemyMovingDir = vmath.normalize(self.enemyMovingDir)
end

local function handleWallsCollisions(self)
	-- Reset enemy moving directions if needed
	if (self.wallsCollider.top and self.enemyMovingDir.y > 0) or (self.wallsCollider.bottom and self.enemyMovingDir.y < 0) then
		self.enemyMovingDir.y = 0
	end
	if (self.wallsCollider.left and self.enemyMovingDir.x < 0) or (self.wallsCollider.right and self.enemyMovingDir.x > 0) then
		self.enemyMovingDir.x = 0
	end
end

local function updateAnimation(self)
	-- Set proper animation based on enemy moving directory
	if self.enemyMovingDir.x < -0.3 and self.enemyMovingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up_left")})
	elseif self.enemyMovingDir.x > 0.3 and self.enemyMovingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up_right")})
	elseif self.enemyMovingDir.x < -0.3 and self.enemyMovingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down_left")})
	elseif self.enemyMovingDir.x > 0.3 and self.enemyMovingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down_right")})
	elseif self.enemyMovingDir.y > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up")})
	elseif self.enemyMovingDir.y < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down")})
	elseif self.enemyMovingDir.x < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_left")})
	elseif self.enemyMovingDir.x > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_right")})
	else 
		msg.post("#sprite", "play_animation", {id = hash("enemy_down")})
	end
end

local function moveEnemy(self, dt)
	-- Change enemy position basen on his movements or forces that works on him
	if self.distanceToClosestPlayer >= self.followDistance or self.moveForce.x > 0 or self.moveForce.y > 0 then
		self.enemyPos = self.enemyPos + self.enemyMovingDir * self.movingSpeed * dt + self.moveForce * dt
		go.set_position(self.enemyPos)
		updateAnimation(self)
	end
end

local function reduceForces(self, dt)
	-- Reduce force that works on enemy
	if self.moveForce.x > 1 then
		self.moveForce.x = self.moveForce.x - self.moveForceReduction * dt
	elseif self.moveForce.x < -1 then
		self.moveForce.x = self.moveForce.x + self.moveForceReduction * dt
	else
		self.moveForce.y = 0
	end
	if self.moveForce.y > 1 then
		self.moveForce.y = self.moveForce.y - self.moveForceReduction * dt
	elseif self.moveForce.y < -1 then
		self.moveForce.y = self.moveForce.y + self.moveForceReduction * dt
	else
		self.moveForce.y = 0
	end
end

local function playDeathAnimation(self)
	-- Change enemy to dead body, play death sound etc.
	local pos = go.get_position()
	go.set_position(vmath.vector3(pos.x, pos.y, -0.98))
	msg.post("#sprite", "play_animation", {id = hash("enemy_killed")})
	msg.post("#death_sound", "play_sound", {gain = 0.5})
end

local function handleDeath(self, dt)
	-- Handling death when health drops below 0
	if self.health <= 0 then
		if self.isKilled == false then
			playDeathAnimation(self)
			self.killedTimer = 5
			self.isKilled = true
		end
		-- Set enemy as inactive and move him out of gamescreen
		if self.killedTimer <= 0 then
			enemyManager.setEnemyInactive(go.get_id())
		else
			self.killedTimer = self.killedTimer - dt
		end
	end
end

local function resetTimers(self, dt)
	if self.knockbackTimer > 0 then
		self.knockbackTimer = self.knockbackTimer - 1 * dt
	end
	if self.moveForceTimer > 0 then
		self.moveForceTimer = self.moveForceTimer - 1 * dt
	end
	if self.checkClosestPlayerPosTimer > 0 then
		self.checkClosestPlayerPosTimer = self.checkClosestPlayerPosTimer - 1 * dt
	end
end

local function resetWallColliders(self)
	self.wallsCollider.top = false
	self.wallsCollider.bottom = false
	self.wallsCollider.left = false
	self.wallsCollider.right = false
end

function update(self, dt)
	--Checks if the game is paused
	if globals.getPause() then
		return
	end
	-- Save go position once to limit number of "go.get_position" uses 		
	self.enemyPos = go.get_position()
	if not self.isKilled then
		if self.checkClosestPlayerPosTimer <= 0 then 
			lookForClosestPlayer(self)
			self.checkClosestPlayerPosTimer = 0.25
		end	
		handleWallsCollisions(self)
		moveEnemy(self, dt)
		reduceForces(self, dt)
	end
	handleDeath(self, dt)
	resetTimers(self, dt)
	resetWallColliders(self)
end

local function enemiesCollisions(self, message_id, message, sender)
	local otherEnemyPos = go.get_position(message.other_id)
	local otherEnemyUrl = msg.url(nil, message.other_id, "enemy")

	-- Get pushed from other enemy if its not a dead body
	local isOtherEnemyKilled = go.get(otherEnemyUrl, "isKilled")
	if isOtherEnemyKilled == false then
		-- Count direction of force that needs to be applied
		local forceDir = vmath.vector3(self.enemyPos.x - otherEnemyPos.x, self.enemyPos.y - otherEnemyPos.y, 0)
		forceDir = vmath.normalize(forceDir)		
		self.moveForce = vmath.vector3(self.moveForce.x + forceDir.x * self.movingSpeed, self.moveForce.y + forceDir.y * self.movingSpeed, 0)				
	end
end

local function playersAttacksCollisions(self, message_id, message, sender)
	local attackUrl = msg.url(nil, message.other_id, "rangeAttack")
	local attackDmg = go.get(attackUrl, "damage")		
	self.health = self.health - attackDmg
	label.set_text("#label_hp", self.health)
end

local function playersCollisions(self, message_id, message, sender)
	local playerUrl = msg.url(nil, message.other_id, "player")
	local isPlayerVurnerable = go.get(playerUrl, "isVulnerable")
	--Send message about dealt damage
	msg.post(playerUrl,"hit", {dmg = self.damage})
	-- Get knockback if player took damage or get pushed if dont
	if self.knockbackTimer <= 0 and isPlayerVurnerable then
		self.moveForce = vmath.vector3(self.moveForce.x - self.enemyMovingDir.x * self.knockbackForce, self.moveForce.y - self.enemyMovingDir.y * self.knockbackForce, 0)
		self.knockbackTimer = 0.5
		self.moveForceTimer = 0.1
	elseif self.moveForceTimer <= 0 then
		self.moveForce = vmath.vector3(self.moveForce.x - self.enemyMovingDir.x * self.movingSpeed * 2.5, self.moveForce.y - self.enemyMovingDir.y * self.movingSpeed * 2.5, 0)
		self.moveForceTimer = 0.1
	end
end

local function wallsCollisions(self, message_id, message, sender)
	if message.group == hash("walls") then
		if sender.fragment == hash("wallsTopCollider") then
			self.wallsCollider.top = true
			if self.moveForce.y > 0 then
				self.moveForce.y = 0
			end
		elseif sender.fragment == hash("wallsBottomCollider") then
			self.wallsCollider.bottom = true
			if self.moveForce.y < 0 then
				self.moveForce.y = 0
			end
		end
		if sender.fragment == hash("wallsLeftCollider") then
			self.wallsCollider.left = true
			if self.moveForce.x < 0 then
				self.moveForce.x = 0
			end
		elseif sender.fragment == hash("wallsRightCollider") then
			self.wallsCollider.right = true
			if self.moveForce.x > 0 then
				self.moveForce.x = 0
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") and self.isKilled == false then		
		if message.group == hash("enemies") then
			enemiesCollisions(self, message_id, message, sender)
		elseif message.group == hash("attacks") then
			playersAttacksCollisions(self, message_id, message, sender)
		elseif message.group == hash("players") then
			playersCollisions(self, message_id, message, sender)
		end
	elseif message_id == hash("contact_point_response") then	
		wallsCollisions(self, message_id, message, sender)	
	elseif message_id == hash("setInactive") then
		self.health = self.maxHealth
		self.isKilled = true
	elseif message_id == hash("setActive") then
		label.set_text("#label_hp", self.health)
		self.isKilled = false
	end
end