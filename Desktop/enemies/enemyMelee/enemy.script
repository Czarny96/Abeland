local playersManager = require "managers.playersManager"
local enemyManager = require "managers.enemyManager"

-- Global properties
go.property("enemyMovingDir", vmath.vector3(0, 0, 0))
go.property("maxHealth", 100)
go.property("health", 100)
go.property("damage", 10)
go.property("isKilled", false)
go.property("isRanged", false)
go.property("moveForce", vmath.vector3(0, 0, 0))

function init(self)
	-- Local settings
	self.movingSpeed = 50
	self.followDistance = 30
	self.knockbackForce = 300
	self.moveForceReduction = 500
	self.killedTimer = 0
	self.knockbackTimer = 0
	self.moveForceTimer = 0
	-- Local Colliders
	self.wallsCollider = {top = false, bottom = false,left = false,right = false}
	-- Health label
	label.set_text("#label_hp", self.health)
end

local function updateAnimation(self)
	-- Set proper animation based on enemy moving directory
	if self.enemyMovingDir.x < -0.3 and self.enemyMovingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up_left")})
	elseif self.enemyMovingDir.x > 0.3 and self.enemyMovingDir.y > 0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up_right")})
	elseif self.enemyMovingDir.x < -0.3 and self.enemyMovingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down_left")})
	elseif self.enemyMovingDir.x > 0.3 and self.enemyMovingDir.y < -0.3 then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down_right")})
	elseif self.enemyMovingDir.y > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_up")})
	elseif self.enemyMovingDir.y < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_down")})
	elseif self.enemyMovingDir.x < -0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_left")})
	elseif self.enemyMovingDir.x > 0.3  then
		msg.post("#sprite", "play_animation", {id = hash("enemy_right")})
	else 
		msg.post("#sprite", "play_animation", {id = hash("enemy_down")})
	end
end

local function playDeathAnimation(self)
	-- Change enemy to dead body, play death sound etc.
	local pos = go.get_position()
	go.set_position(vmath.vector3(pos.x, pos.y, -0.98))
	msg.post("#sprite", "play_animation", {id = hash("enemy_killed")})
	msg.post("#death_sound", "play_sound", {gain = 0.5})
end

function update(self, dt)
	if playersManager.getActivePlayersIDs() ~= 0 and self.isKilled == false then

		-- Count possition diffrence between closest player and enemy to designate enemy moving direction
		local enemyPos = go.get_position()
		local closestPlayerID = playersManager.getClosestPlayerID(enemyPos)
		local closestPlayerPos = playersManager.getPlayerPos(closestPlayerID)
		local distanceToClosestPlayer = vmath.length(closestPlayerPos - enemyPos)
		local positionDiffrence = closestPlayerPos - enemyPos
		self.enemyMovingDir = vmath.vector3(positionDiffrence.x, positionDiffrence.y, 0)

		--Collisions with arena walls
		if (self.wallsCollider.top and self.enemyMovingDir.y > 0) or (self.wallsCollider.bottom and self.enemyMovingDir.y < 0) then
			self.enemyMovingDir.y = 0
		end
		if (self.wallsCollider.left and self.enemyMovingDir.x < 0) or (self.wallsCollider.right and self.enemyMovingDir.x > 0) then
			self.enemyMovingDir.x = 0
		end
		self.enemyMovingDir = vmath.normalize(self.enemyMovingDir)

		-- Change enemy position basen on his movements or forces that works on him
		if distanceToClosestPlayer >= self.followDistance or self.moveForce.x > 0 or self.moveForce.y > 0 then
			enemyPos = enemyPos + self.enemyMovingDir * self.movingSpeed * dt + self.moveForce * dt
			go.set_position(enemyPos)
			updateAnimation(self)
		end

		-- Reduce force that works on enemy
		if self.moveForce.x > 1 then
			self.moveForce.x = self.moveForce.x - self.moveForceReduction * dt
		elseif self.moveForce.x < -1 then
			self.moveForce.x = self.moveForce.x + self.moveForceReduction * dt
		else
			self.moveForce.y = 0
		end
		if self.moveForce.y > 1 then
			self.moveForce.y = self.moveForce.y - self.moveForceReduction * dt
		elseif self.moveForce.y < -1 then
			self.moveForce.y = self.moveForce.y + self.moveForceReduction * dt
		else
			self.moveForce.y = 0
		end
	end

	-- Death when health drops below 0
	if self.health <= 0 then
		if self.isKilled == false then
			playDeathAnimation(self)
			self.killedTimer = 10
			self.isKilled = true
		end

		-- Set enemy as inactive and move him out of gamescreen
		if self.killedTimer <= 0 then
			enemyManager.setEnemyInactive(go.get_id())
		else
			self.killedTimer = self.killedTimer - dt
		end
	end

	-- Timers reset
	if self.knockbackTimer > 0 then
		self.knockbackTimer = self.knockbackTimer - 1 * dt
	end
	if self.moveForceTimer > 0 then
		self.moveForceTimer = self.moveForceTimer - 1 * dt
	end
	
	-- Collider flags reset
	self.wallsCollider.top = false
	self.wallsCollider.bottom = false
	self.wallsCollider.left = false
	self.wallsCollider.right = false
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") and self.isKilled == false then

		-- Collisions with other enemies
		if message.group == hash("enemies") then
			local enemyPos = go.get_position()
			local otherEnemyPos = go.get_position(message.other_id)
			local otherEnemytUrl = msg.url(nil, message.other_id, "enemy")
			
			-- Get pushed from other enemy if its not a dead body
			local isOtherEnemyKilled = go.get(otherEnemytUrl, "isKilled")
			if isOtherEnemyKilled == false then
				-- Count direction of force that needs to be applied
				local forceDir = vmath.vector3(enemyPos.x - otherEnemyPos.x, enemyPos.y - otherEnemyPos.y, 0)
				forceDir = vmath.normalize(forceDir)		
				self.moveForce = vmath.vector3(self.moveForce.x + forceDir.x * self.movingSpeed, self.moveForce.y + forceDir.y * self.movingSpeed, 0)				
			end

		-- Collisions with players attacks
		elseif message.group == hash("attacks") then
			local attackUrl = msg.url(nil, message.other_id, "rangeAttack")
			local attackDmg = go.get(attackUrl, "damage")		
			self.health = self.health - attackDmg
			label.set_text("#label_hp", self.health)

		-- Collisions with players	
		elseif message.group == hash("players") then
			local enemyPos = go.get_position()
			local playerUrl = msg.url(nil, message.other_id, "player")
			local isPlayerVurnerable = go.get(playerUrl, "isVulnerable")
			
			--Send message about dealt damage
			msg.post(playerUrl,"hit", {dmg = self.damage})

			-- Get knockback if player took damage or get pushed if dont
			if self.knockbackTimer <= 0 and isPlayerVurnerable then
				self.moveForce = vmath.vector3(self.moveForce.x - self.enemyMovingDir.x * self.knockbackForce, self.moveForce.y - self.enemyMovingDir.y * self.knockbackForce, 0)
				self.knockbackTimer = 0.5
				self.moveForceTimer = 0.1
			elseif self.moveForceTimer <= 0 then
				self.moveForce = vmath.vector3(self.moveForce.x - self.enemyMovingDir.x * self.movingSpeed * 2.5, self.moveForce.y - self.enemyMovingDir.y * self.movingSpeed * 2.5, 0)
				self.moveForceTimer = 0.1
			end
		end
	end
	if message_id == hash("contact_point_response") then	
		--Walls
		if message.group == hash("walls") then
			if sender.fragment == hash("wallsTopCollider") then
				self.wallsCollider.top = true
				if self.moveForce.y > 0 then
					self.moveForce.y = 0
				end
			elseif sender.fragment == hash("wallsBottomCollider") then
				self.wallsCollider.bottom = true
				if self.moveForce.y < 0 then
					self.moveForce.y = 0
				end
			end
			if sender.fragment == hash("wallsLeftCollider") then
				self.wallsCollider.left = true
				if self.moveForce.x < 0 then
					self.moveForce.x = 0
				end
			elseif sender.fragment == hash("wallsRightCollider") then
				self.wallsCollider.right = true
				if self.moveForce.x > 0 then
					self.moveForce.x = 0
				end
			end
		end
	end
end