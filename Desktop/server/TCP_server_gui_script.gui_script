local tcpServer = require "defnet.tcp_server"
local p2pDiscovery = require "defnet.p2p_discovery"

local clientsManager = require "managers.clientsManager"
local playersManager = require "managers.playersManager"

local sessionGenerator = require "server.sessionGenerator"

local TCP_SERVER_PORT = 5555
local PORT = 50000

local dtPassed = 0
--Proxy to access server in functions other than self
local serverHandler = nil
local currentSession = nil
local startP2P = false

local function sendMessageToAllActivePlayers(mess)
	for ip,client in pairs(clientsManager.returnActiveClients()) do
		serverHandler.send(mess.."\n\r", client)
	end
end

function createSession()
	if currentSession == nil then
		currentSession = sessionGenerator.create()
		currentSession.start()
		sendMessageToAllActivePlayers("StartGame")
	end
end

local function msgActivePlayersChange()
	playersManager.setActivePlayersIDs()
end

local function routeFrameToRespFunc(frame,ip, client)
	local frameId = string.sub(frame,1,1)

	if frameId == "M" and currentSession ~=nil then 
		clientsManager.translateDataToPlayer(frame, ip)
	elseif frameId == "N" then 
		clientsManager.addNickToPlayer(frame, ip)
		clientsManager.sendNickToMenu(ip)
	elseif frameId == "C" then 
		if clientsManager.tryToLockPlayerClass(frame, ip) then
			serverHandler.send(frame.."\n\r", client)
			clientsManager.sendClassToMenu(ip)
		end
	elseif frameId == "G" then
		clientsManager.setPlayerReadines(ip, true)
		if clientsManager.areAllPlayersReady() then
			msgActivePlayersChange()
			createSession()
		end
	end
	
end


local function on_data(data, ip, port, client)
	clientsManager.resetPlayerInactivityTimeCounter(ip)
	
	if  not clientsManager.isPlayerActive(ip) then
		clientsManager.activatePlayer(ip)
		msgActivePlayersChange()
	end
	
	routeFrameToRespFunc(data,ip,client)
end 

local function on_client_connected(ip, port, client) 
	clientsManager.addPlayer(ip, client)
	msgActivePlayersChange()
end

local function on_client_disconnected(ip, port, client)
	--TODO: add function, to remove data from menu
	clientsManager.removePlayer(ip)
	msgActivePlayersChange()
end

function init(self)
	server = tcpServer.create(TCP_SERVER_PORT, on_data, on_client_connected, on_client_disconnected)
	self.server = server
	serverHandler = self.server
	self.server.start()

	-- broadcast init
	self.p2p = p2pDiscovery.create(PORT)
	self.p2p.broadcast("findme")
	print("Server Initialized")
end

function final(self)
	if self.server then
		self.server.stop()
	end
end

function update(self, dt)
	-- Add update code here
	
	--TODO: start updated when inside champion select
	if startP2P == true then 
		self.p2p.update(dt)
	end
	
	--TODO: adjust clocking for optimal user experience
	if  clientsManager.isAnyPlayer() and dtPassed > 0.016 then
		for ip,client in pairs(clientsManager.returnAllClients()) do

			if clientsManager.isPlayerActive(ip) then
				self.server.send("btn_data\n\r", client)
			end
			
			clientsManager.incrementPlayerInactivityTimeCounterByDT(ip,dtPassed)

			if clientsManager.getPlayerInactivityTimeCounter(ip) > 2 and clientsManager.isPlayerActive(ip) then
				clientsManager.desactivatePlayer(ip)
				msgActivePlayersChange()
			elseif clientsManager.getPlayerInactivityTimeCounter(ip) > 10 and not clientsManager.isPlayerActive(ip) then
				self.server.remove_client(client)
			end
		end
		dtPassed = 0
	elseif currentSession~=nil then
		dtPassed = dtPassed + dt
	end
	
	if self.server then
		self.server.update()	
	end
	
	if currentSession ~= nil then
		currentSession.update() 
		if currentSession.isGameOver()  then
			sendMessageToAllActivePlayers("EndGame")
			currentSession = nil
			startP2P = false
		end
		
	end
end

function on_message(self, message_id, message, sender)
	if  message_id == hash("reset") then
		if self.currentSession then
			sendMessageToAllActivePlayers("Reset")
			clientsManager.resetPlayersToDefault()
			self.currentSession.setGameOverFlag(1)

		end
	elseif  message_id == hash("championSelect") then
		startP2P = true
	end

end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
