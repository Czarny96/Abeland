local tcpServer = require "defnet.tcp_server"
local p2pDiscovery = require "defnet.p2p_discovery"
local translationLayer = require "server.TranslationLayer"

local TCP_SERVER_PORT = 5555
local PORT = 50000

local clientsTable = {}
local createdPlayersTable = {}
local createdPlayerInactivityTable = {}
local currentPlayers = 0
local dtPassed = 0
local serverHandler = nil
local unansweredMessages = 0

-- For rudy, to get playersIDs
function returnPlayersIDs()
	local playerIDs = {}
	for ip,player in pairs(createdPlayersTable) do
		table.insert(playerIDs, player)
	end
	return playerIDs
end

local function inactivePlayerHandler(objectID)
	if createdPlayerInactivityTable[objectID][2] == false then
		createdPlayerInactivityTable[objectID][2] = true 
		translationLayer.desactivatePlayer(objectID)
	else
		
		translationLayer.activatePlayer(objectID)
		createdPlayerInactivityTable[objectID][2] = false 
	end
end


local function on_data(data, ip, port, client)
	
	-- Name "true" is used, because ip recived in function is ip belonging to the server
	local trueClientIP, trueClientPort = client:getpeername()
	print("TCP server received data '" .. data .. "' from " .. trueClientIP .. ":" .. trueClientPort)
	translationLayer.translateFrameToPlayer(data, createdPlayersTable[trueClientIP])
	createdPlayerInactivityTable[createdPlayersTable[trueClientIP]][1] = 0.0
	createdPlayerInactivityTable[createdPlayersTable[trueClientIP]][3] = 0
	if createdPlayerInactivityTable[createdPlayersTable[trueClientIP]][2] == true then
		serverHandler.flushClient(client)
		serverHandler.send("flush\n\r", client)
		inactivePlayerHandler(createdPlayersTable[trueClientIP])
		
	end
	
end 

local function on_client_connected(ip, port, client) 
	-- Name "true" is used, because ip recived in function is ip belonging to the server
	local trueClientIP, trueClientPort = client:getpeername()
	print("Client connected from " .. trueClientIP .. ":" .. trueClientPort)

	if currentPlayers < 4 then
		clientsTable[trueClientIP] = client
		currentPlayers = currentPlayers + 1
		
		-- WARNING: Temporally fixed to call one factory, until mechanism to chose class at the controller side is avaible
		createdPlayersTable[trueClientIP] = translationLayer.createPlayerObject("go#knightFactory", vmath.vector3(147, 297, 0))
		createdPlayerInactivityTable[createdPlayersTable[trueClientIP]] = {0.0, false , 0.0}
	else
		print("To many clients, cannot connected another one")
	end
	
end

local function on_client_disconnected(ip, port, client)
	-- Name "true" is used, because ip recived in function is ip belonging to the server
	local trueClientIP, trueClientPort = client:getpeername()
	print("Client disconnected from " .. trueClientIP .. ":" .. trueClientPort)
	currentPlayers = currentPlayers - 1
	clientsTable[trueClientIP] =  nil
	--TODO: decide what to do when player disconnects
	translationLayer.RemovePlayerObject(createdPlayersTable[trueClientIP])
	createdPlayersTable[trueClientIP] = nil
end


function init(self)
	-- Add initialization code here
	msg.post(".", "acquire_input_focus")

	-- tcp server init
	server = tcpServer.create(TCP_SERVER_PORT, on_data, on_client_connected, on_client_disconnected)
	self.server = server
	serverHandler = server
	self.server.start()

	-- broadcast init
	self.p2p = p2pDiscovery.create(PORT)
	self.p2p.broadcast("findme")
	print("Server Initialized")
end

function final(self)
	-- Add finalization code here
	msg.post(".", "release_input_focus")
	if self.server then
		self.server.stop()
	end
end

function update(self, dt)
	-- Add update code here
	self.p2p.update()
	
	--TODO: adjust clocking for optimal user experience
	if  currentPlayers > 0 and dtPassed > 0.01 then
		for ip,client in pairs(clientsTable) do
			if createdPlayerInactivityTable[createdPlayersTable[ip]][2]==false then
				if createdPlayerInactivityTable[createdPlayersTable[ip]][3] < 0.1 then
					self.server.send("btn_data\n\r", client)
				end
				createdPlayerInactivityTable[createdPlayersTable[ip]][3] = createdPlayerInactivityTable[createdPlayersTable[ip]][3] + dt
				createdPlayerInactivityTable[createdPlayersTable[ip]][1] = createdPlayerInactivityTable[createdPlayersTable[ip]][1] + dt
			end
		end
		dtPassed = 0
	else
		dtPassed = dtPassed + dt
	end

	if  currentPlayers > 0 then
		for ip,player in pairs(createdPlayersTable) do
			-- Value to adjust
			if createdPlayerInactivityTable[player][1] > 1 and createdPlayerInactivityTable[player][2] == false then
				inactivePlayerHandler(player)
			end
		end
	end
	
	if self.server then
		self.server.update()	
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
